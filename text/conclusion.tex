\chapter{Conclusion \& Future Work}\label{chapter:conclusion}
\todonum{conclusion}


\section{Proof Automation}\label{future:proofautomation}
\begin{itemize}
\item Fully verify XMonad~\ref{sec:structures}
\end{itemize}

\section{Intersection Types}\label{future:intersection}
\begin{itemize}
\item Various Versions of library functions (XMonad)~\ref{sec:structures}
\item Various labels for primitive types~\ref{sec:typing}
\end{itemize}

\section{Bound Inference}\label{future:ghost}
\begin{itemize}
\item How can we \textit{infer} bounded refinement types
to eliminate ghost arguments (~\ref{sec:discussion})?
\end{itemize}

\section{{Fixed-width integer and floating-point numbers}}\label{future:fp}
\begin{itemize}
\item Soundness of fixpoint operators (~\ref{sec:discussion})?
\end{itemize}


\section{How do we measure the size of a continuation}\label{future:continuations}
\begin{itemize}
\item For termination on text~\ref{sec:memory-safety} and awake (see github issue)
\end{itemize}


\section{Gradual Refinement Types}\label{future:gradual}
\begin{itemize}
\item How should assumptions~\ref{sec:discussion} behave in the code? 
\end{itemize}


\section{Error Reporting \& Diagnosis}\label{future:errorreporting}
\begin{itemize}
\item Counter example generation 
\item Code and spec completion synthesis
\end{itemize}

\section{Inference of Abstract and Bounded Refinement Types}


\section{Automation on Theorem Prover}\label{future:theoremproving}
Our evaluation shows that refinement reflection
lets us prove deep specifications of a variety
of implementations, and identifies
important avenues for research.
%
First, while proofs are \emph{possible}, they can
sometimes be \emph{cumbersome}. For example, in
the proof of associativity of the monadic bind
operator for the @Reader@ monad three of eight
(extensional) equalities required explanations,
some nested under multiple $\lambda$-abstractions.
%
Thus, it would be valuable to use recent
advances in refinement-based synthesis~\cite{polikarpova16}
to automate proof construction.
%
Second, while our approach to $\alpha$- and
$\beta$-equivalence is sound, we do not know
if it is \emph{complete}. We conjecture it is,
due to the fact that our refinement terms
are from the simply typed lambda calculus (STLC).
%
Thus, it would be interesting to use the
normalization of STLC to develop a sound
and complete SMT axiomatization, thereby
automating proofs predictably.