\section{Conclusion} \label{sec:boundedrefinementtypes:conclusion}
We presented a notion of bounded quantification for refinement types
and show how it expands the expressiveness of refinement typing
by using it to develop typed combinators for:
%
(1)~relational algebra and safe database access,
%
(2)~Floyd-Hoare logic within a state transformer
    monad equipped with combinators for branching
    and looping, and
%
(3)~using the above to implement a refined IO
    monad that tracks capabilities and resource usage.
%
This leap in expressiveness comes via a translation to ``ghost" functions,
which lets us retain the automated and decidable SMT based checking and
inference that makes refinement typing effective in practice.

With Bounded Refinement Types we get \textit{relatively complete} 
expressiveness of specification, that is we can use refinement types
to express any property referring to the underlying (decidable) logic. 
%
Thus our expressiveness power is still limited, 
we cannot use arbitrary Haskell functions is the specifications. 
%
Next we see how to overcome this expressiveness limitation 
and thus allow arbitrary Haskell expressions into the specifications
while still preserving decidable type checking. 