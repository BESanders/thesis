\section{Overview}\label{sec:boundedrefinementtypes:overview}
\begin{comment}
<->append 
- complete cmp complete
<-> composition cmp A
- filter cmp Kaki
- state cmp Nik
\end{comment}

\subsection{Function Composition: Bringing Everything into Scope!}

We start the overview of Bounded Refinement Types by typing function composition.
%
@cmp@ is a function that takes an input two functions @f@ and @g@ and composes them.
%
\begin{code}
cmp f g x = f (g x)
\end{code}
%
Now assume that the function @f@ (resp. @g@) has some postcondition @p@ (resp. @q@) on its input @y@ (resp. @z@), \ie
%
\begin{code}
  f :: y:b -> c<p y> 
  g :: z:a -> b<q z>
\end{code}
%
Then, what is the postcondition of the composition @cmp f g@?
%
The function @cmp f g@ takes an input @x@ and returns a result that satisfies some 
relation @r@ on @x@. 
%
The relation @r@ is constraint by the fact that @p w@ should imply @r x@
\textit{for some} @w@ that satisfies @g@'s post condition @q x@.
%
The above constraint translates directly into a subtyping query:
\begin{code}
  {x:a, w:b<q x> |- c<p w> <: c<r x>}
\end{code}
We call such subtyping queries a \textit{constraint} that can be used to 
\textit{bound} Abstract Refinement Types, in that it constraints the relations
that can be used to instrantiate the abstract refinements @p@, @q@ and @r@.
%
With the above constraint the post constcondition of @cmp f g@
on an input @x@ reduces to @r x@.
%
All the above reasoning is summarized in the following type for @cmp@:
\begin{code}
cmp :: forall <p :: b -> c -> Bool, q :: a -> b -> Bool, r :: a -> c -> Bool>. 
       {x:a, w:b<q x> |- c<p w> <: c<r x>}
       f:(y:b -> c<p y>)
    -> g:(z:a -> b<q z>)
    ->   x:a -> c<r x>
\end{code}
%

The above type in theory \textit{cannot} be described by Abstract Refinement Types, 
without bounds, as there is no clear way to describe the final post condition. 
%
In practice \toolname gives function composition a type that, as the above type,
describes that 
the function @cmp f g@ takes an input @x@ and returns a result that satisfies 
@q w@
\textit{for some} @w@ that satisfies @g@'s post condition @q x@:
%
\begin{code}
cmp :: forall <p :: b -> c -> Bool, q :: a -> b -> Bool>. 
       f:(y:b -> c<p y>)
    -> g:(z:a -> b<q z>)
    ->  x:a -> exists [w:b<q x>]. c<q w>
\end{code}

This existential is required as the intermediate result @w = g x@ is not in scope at the 
type signature. 
%
Bounded refinement types address this issue simply:
In the constraints there is an environment thus variables with any properties can be assumed.
%

Bounded Refinement Types is a natural generalization of
Abstract Refinement Types with existentials, 
in that inside the constraint bounds any variable with specified types are brought 	\textit{into scope},
%
As we shall shortly see bounded refinement types have various applications.

\mypara{Using Bounded Types}

Next we describe how @cmp@ , 
\ie a function with Bounded Refinement Types, can be used.
%
As a trivial usage, consider a function @incr@ that increases its argument by one: 
%
\begin{code}
incr :: x:Nat -> {v:Nat | v == x + 1}
incr x = x + 1
\end{code}

If we compose @incr@ by itself we get a function that increases its argument by 2
\begin{code}
incr2 :: x:Nat -> {v:Nat | v = x + 2}
incr2 = cmp incr incr
\end{code}

At the call @cmp incr incr@ the abstract refinements @p@, @q@ and @r@ of @cmp@
are appropriately instantiated to @\x v -> v = x + 1@, @\x v -> v = x + 1@, and @\x v -> v = x + 2@.
%
Thus, the subtyping constraint reduces to proving the subtyping 
%
\begin{code}
  x:a, {w:b | w = x + 1} |- {v:c |  v = w + 1} <: {v:c | v = x + 2}
\end{code}
%
This in turn, using the standard refinement types regime, reduces to 
the logical implication
$$
  \forall x, w, v.  w = x + 1 \Rightarrow v = w + 1\Rightarrow v = x + 2
$$
%
that can be trivially proven by an SMT solver.

\mypara{Constraint Translation}
Constraints on functions can be thought of as 
\textit{axioms}.
%
For example,  the constraint of @cmp@ translates to the following logical axiom:
$$ 
\forall x w z. q x w \Rightarrow p w \Rightarrow r x z\ (1)
$$
%
We need to be able to apply the above axiom at any values inside @cmp@'s body.
%
To do so, we translate the constraint to a \textit{axiomatic function}
\ie a function argument whose application ensures application of the axiom. 
%
At our @cmp@ example, the axiomatic function is just a function argument with type
%
\begin{code}
        c:(x:a ->  w:b -> z:c -> {v:Unit | true && q x w => p w z => r x z)
\end{code}
%
Thus the type of @cmp@ translates to 
% 
\begin{code}
cmp :: forall <p :: b -> c -> Bool, q :: a -> b -> Bool, r :: a -> c -> Bool>. 
        c:(x:a ->  w:b -> z:c -> {v:Unit | true && q x w => p w z => r x z)
    -> f:(y:b -> c<p y>)
    -> g:(z:a -> b<q z>)
    -> x:a -> c<r x>
\end{code}

To transform the body of @cmp@ we crucially transform the code in ANF~\citep{}
so that all intermediate values are into scope.
%
Then, we apply the axiomatic functions (here @c@) whenever possible.
% 
Following this we translate the body of @cmp@ to the following safe code.
The transformation totally eliminated bounded refinement types.
%
\begin{code}
cmp c f g x 
  = let w = g x in 
     let r  = f x   in
     let _ = c x w r -- axiom application
     r   
\end{code}

Analogous transformation is applied when functions with bounded types are used.
As an example, at the call site of @cmp@ we need to provide the implementation of a function
that proves the axiom $(1)$. 
%
Unsurprisingly, a trivial function that always returns unit is such a function, 
as, by subtyping, the application is safe \texttt{iff} axiom $(1)$ holds. 
%
Thus, the call site of @cmp@ translates to 
\begin{code}
incr2 = cmp (\_ _ _ -> ()) incr incr
\end{code}

We note that the translated code is safe and does not contain any Bounded Refinement Types, 
thus its soundness is reduced to soundness of the target of the translation language; 
which is the language of Abstract Refinement Types.
%
The catch of the translation is that it is not clear when we should instantiate the axioms, 
equivalently, it is not clear when to apply the axiomatic functions and with what arguments.
%
Our translation follows the naive approach of applying the axiomatic functions whenever possible.
%
Of course the code can be expanded exponentially with respect of the number of variables, 
but since the result of the axiomatic function application is always unit, 
these applications are dead code, at run time, and can be optimized by the compiler. 


\subsection{Appending Constraint Lists}
The next application of Bounded Refinement Types is aspired by
the sorting routine quick sort.
%
Quick sort chooses a pivot element @x@,
then constructs and recursively sorts two lists:
the list of elements less than and greater than or equal to @x@.
%
Then appends the two sorted lists. 
%

We have used Abstract Refinement Types before to express list sortedness 
and verify quicksort. 
%
During verification we had to deal with a persisting issue:
how can we type list concatination to express that given 
(1)~a sorted list of elements less than @x@, and 
(2)~a sorted list of elements greater than or equal to @x@
it returns a sorted list. 
%
The difficulty of this issue arises from the fact that the desired type of 
list concatination, at its call site, naturally refers to the pivot @x@, 
but @x@ is not at scope at the definition of @(++)@.
%
Furthermore, in a type signature we are not allowed to \textit{refer} to 
the elements of a list, as there exists no quantification over them.
%
Before bounds in refinement types, the remedy was simple:
we added a ghost variable to @(++)@. 
%
With refinement type bounds we give @(++)@ a type that 
even being more verbose, does not require extra ghost variables. 
%

The bounded type for @(++)@ takes as input a sorted list @xs@ and a sorted list @ys@. 
%
Moreover, each element of @xs@ satisfies a predicate @p@ and 
each of the elements in @ys@ satisfies @q@.
%
The bounded constraint restricts @p@ and @q@ so that 
for every @x:a<p>@ if @v:a<q>@ then @x <= v@:
\begin{code}
 (++) :: forall <p :: a -> Prop, q :: a -> Prop>.
          Ord a => 
         {x:a<p> |- a<q> <: {v:a| x <= v}} 
         xs:SortedList (a<p>) -> ys:SortedList (a<q>) -> SortedList a
\end{code}

At the call site of @(++)@ we instantiate the abstract refinements @p := \v -> v < x@ 
and @q := \v -> v >= x@ thus the required constraint can be proved true:

\begin{code}
type SortedList a = [a]<{\x v -> v >= x}>

qsort :: (Ord a) => xs:[a] -> SortedList a
qsort []       = []
qsort (x:xs) = (qsort [y | y <- xs, y < x]) ++ (x:(qsort [z | z <- xs, z >= x])) 
\end{code}




%%%%% COMMENT \begin{comment}
%%%%% COMMENT \subsection{Translation By Example}
%%%%% COMMENT Translation by example: Function Composition
%%%%% COMMENT Two constraints 
%%%%% COMMENT \begin{itemize}
%%%%% COMMENT \item The post condition of @g@ on the appropriate input implies the precondition of @f@, and
%%%%% COMMENT \item the post condition of @f@ in the appropriate input implied the post condition @q@.
%%%%% COMMENT \end{itemize}
%%%%% COMMENT 
%%%%% COMMENT Let   @c1 = x:a<p>, w:b<qg x> |- c<qf w> <: c<q x>@
%%%%% COMMENT Let   @c2 = x:a<p> |- b<qg x> <: b<pf>@
%%%%% COMMENT 
%%%%% COMMENT \begin{code}
%%%%% COMMENT  cmp :: forall a b c <p, qf, pf, qg, q>. 
%%%%% COMMENT         {c1}{c2}
%%%%% COMMENT         f:(y:b<pf> -> c<qf y>)
%%%%% COMMENT     -> g:(z:a<p > -> b<qg z>)
%%%%% COMMENT     -> x: a<p> -> c<q x>
%%%%% COMMENT cmp f g x = f (g x)
%%%%% COMMENT \end{code}
%%%%% COMMENT 
%%%%% COMMENT \mypara{Step 0: Intermediate Representation}
%%%%% COMMENT 
%%%%% COMMENT \begin{code}
%%%%% COMMENT cmp a b c <p, qf, pf, qg, q> c1 c2 f g x = f (g x)
%%%%% COMMENT \end{code}
%%%%% COMMENT \mypara{Step 1 : Constraints to functions}
%%%%% COMMENT \begin{code}
%%%%% COMMENT  cmp :: forall <p, pf, qf, qg, q>. 
%%%%% COMMENT  c1: (x:a -> w:b -> z:c 
%%%%% COMMENT  -> {p x && qg x w => qf w z => q x z})
%%%%% COMMENT  c2: (x:a -> z:b -> {p x => qg x z => pf z})
%%%%% COMMENT         f:(y:b<pf> -> c<qf y>)
%%%%% COMMENT     -> g:(z:a<p > -> b<qg z>)
%%%%% COMMENT     -> x: a<p> -> c<q x>
%%%%% COMMENT cmp c1 c2 f g x = f (g x)                              
%%%%% COMMENT \end{code}
%%%%% COMMENT 
%%%%% COMMENT \mypara{Step 2: ANF}
%%%%% COMMENT \begin{code}
%%%%% COMMENT cmp c1 c2 f g x = 
%%%%% COMMENT   let w = g x in 
%%%%% COMMENT   let r = f w in 
%%%%% COMMENT   r                              
%%%%% COMMENT \end{code}
%%%%% COMMENT 
%%%%% COMMENT \mypara{Step 3: Using the axioms}
%%%%% COMMENT After @w@ is created, functional axiom @c1@ can be applied, 
%%%%% COMMENT thus we get that @w@ is an appropriate inputs for @f@.
%%%%% COMMENT After @r@ is created, functional axiom @c2@ can be applied, 
%%%%% COMMENT thus we get that @r@ is an appropriate result.
%%%%% COMMENT \begin{code}
%%%%% COMMENT cmp c1 c2 f g x = 
%%%%% COMMENT   let w = g x in 
%%%%% COMMENT   let _ = c1 x w -- {p x => qg x w => pf w}
%%%%% COMMENT   let r = f w in 
%%%%% COMMENT   let _ = c1 x w r -- {p x && qg x w => qf w r => q x r}
%%%%% COMMENT   r                              
%%%%% COMMENT \end{code}
%%%%% COMMENT 
%%%%% COMMENT Using constraint functions 
%%%%% COMMENT 
%%%%% COMMENT The abstract refinements will be automatically instantiated.
%%%%% COMMENT The trivial @\_ -> ()@ functions are appropriate instantiations of the functional arguments,
%%%%% COMMENT as the constraints do hold. Here
%%%%% COMMENT \begin{itemize}
%%%%% COMMENT \item $0 \leq x \Rightarrow w = x + 20 \Rightarrow 10 < w $ 
%%%%% COMMENT \item $0 \leq x \land w = x + 20 \Rightarrow z = w + 22 \Rightarrow z = 42 $ 
%%%%% COMMENT \end{itemize} 
%%%%% COMMENT 
%%%%% COMMENT \begin{code}
%%%%% COMMENT plus1 :: x:Nat -> {v:Nat | v == x + 20}
%%%%% COMMENT plus1 x = x + 20
%%%%% COMMENT 
%%%%% COMMENT plus2 :: x:{v:Nat | v > 10} -> {v:Nat | v == x + 22}
%%%%% COMMENT plus2 x = x + 22
%%%%% COMMENT 
%%%%% COMMENT plus42 :: x:Nat -> {v:Nat | v == x + 42}
%%%%% COMMENT plus42 = cmp plus2 plus1
%%%%% COMMENT \end{code}
%%%%% COMMENT 
%%%%% COMMENT \mypara{Step 0: Intermediate Representation}
%%%%% COMMENT 
%%%%% COMMENT \begin{code}
%%%%% COMMENT plus42 = cmp Int <\v -> v >= 0, \v -> v > 10, \x v -> v = x + 22, \x v -> v = x + 20, \x v -> v = x + 42> {Int, Int |- Int <: Int} {Int |- Int <: Int} plus2 plus1
%%%%% COMMENT \end{code}
%%%%% COMMENT 
%%%%% COMMENT \mypara{Step 1: Constraints as functions}
%%%%% COMMENT \begin{code}
%%%%% COMMENT plus42 = cmp Int <\v -> v >= 0, \v -> v > 10, \x v -> v = x + 22, \x v -> v = x + 20, \x v -> v = x + 42> (\_ _ _ -> ()) (\_ _ -> ()) plus2 plus1
%%%%% COMMENT \end{code}
%%%%% COMMENT \end{comment}
