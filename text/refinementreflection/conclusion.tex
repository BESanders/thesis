\section{Conclusion}\label{sec:refinementreflection:conclusion}

We presented \emph{refinement reflection}, a method
to extend \emph{legacy} languages---with highly tuned
libraries, compilers, and run-times---into theorem provers.
%
The key idea is to reflect the ​code implementing a​
user-defined function into the function's (output)
refinement type.
%
As a consequence, at \emph{uses} of the function,
the function definition is unfolded into the refinement logic
in a precise and predictable manner.
%
We have implemented our approach in \toolname
thereby retrofitting theorem proving into Haskell.
%
We showed how to use reflection to verify
that many widely used instances of the Monoid,
Applicative, Functor and Monad typeclasses
actually satisfy key algebraic laws needed to
making the code using the typeclasses safe.
%
Finally, transforming a mature language---with
highly tuned parallel runtime---into a theorem
prover  enables us to build the first
\emph{deterministic parallelism library}
that verifies assumptions about associativity
and ordering---that are crucial for determinism
but simply assumed by existing systems.

\begin{comment}
Our evaluation shows that refinement reflection
lets us prove deep specifications of a variety
of implementations, but identifies
important avenues for research.
%
First, while proofs are \emph{possible}, they can
sometimes be \emph{cumbersome}. For example, in
the proof of associativity of the monadic bind
operator for the @Reader@ monad three of eight
(extensional) equalities required explanations,
some nested under multiple $\lambda$-abstractions.
%
Thus, it would be valuable to use recent
advances in refinement-based synthesis~\cite{polikarpova16}
to automate proof construction.
%
Second, while our approach to $\alpha$- and
$\beta$-equivalence is sound, we do not know
if it is \emph{complete}. We conjecture it is,
due to the fact that our refinement terms
are from the simply typed lambda calculus (STLC).
%
Thus, it would be interesting to use the
normalization of STLC to develop a sound
and complete SMT axiomatization, thereby
automating proofs predictably.
\end{comment}