In this chapter we introduce \emph{Refinement Reflection}, a method
to extend \emph{legacy} languages---with highly tuned
libraries, compilers, and run-times---into theorem provers,
by letting programmers specify and verify
arbitrary properties of their code simply
by writing programs in the legacy language.

Refinement types, as presented so far, offer a
form of programming with proofs that can be
retrofitted into a programming language.
%
The retrofitting relies upon restricting refinements
to so-called ``shallow'' specifications that
correspond to \emph{abstract} interpretations
of the behavior of functions.
%
For example, refinements make it easy to specify
that the list returned by the @append@ function
has size equal to the sum of those of its inputs.
%
These shallow specifications fall within decidable
logical fragments, and hence, can be automatically
verified using SMT based refinement typing.

Refinements are a pale shadow of what is possible
with dependently typed languages like Coq, Agda
and Idris which permit ``deep'' specification
and verification.
%
These languages come equipped with mechanisms
that \emph{represent} and \emph{manipulate} the
exact descriptions of user-defined functions.
%
For example, we can represent the specification
that the @append@ function is associative, and we
can manipulate (unfold) its definition to write a
small program that constructs a proof of the
specification.
%
Dafny~\citep{dafny}, \fstar~\citep{fstar} and
Halo~\citep{halo} take a step towards
SMT-based deep verification, by encoding
user-defined functions as universally
quantified logical formulas or ``axioms''.
%
This axiomatic approach offers significant automation
but is a devil's bargain as by relying heavily upon
brittle heuristics for ``triggering'' axiom instantiation,
it gives away decidable, and hence, predictable
verification~\citep{Leino16}.
%

In this chapter, we present a new approach to retrofitting
deep verification into existing languages. Our approach
reconciles the automation of SMT-based refinement typing
with decidable and predictable verification, and enables
users to reify pencil-and-paper proofs simply
as programs in the source language.

%
Our key insight is dead simple: the ​code
implementing a​ user-defined function can
be \emph{reflected}​ into the function's
(output) refinement type, thus converting
the function's (refinement) type signature
into a deep specification of the functions
behavior.
%
This simple idea has a profound consequence:
at \emph{uses} of the function, the standard
rule for (dependent) function application
yields a precise, predictable and most
importantly, programmer controllable
means of \emph{instantiating} the deep
specification that is not tethered to
brittle SMT heuristics.
%
Reflection captures deep specifications as
refinements, but poses challenges for the
\emph{logic} and \emph{language}.

\mypara{Logic: Algorithmic Verification}
%
Our first challenge: how can we \emph{encode terms}
from an expressive higher order language in a decidable
refinement logic in order to retain decidable, and hence,
predictable, verification?
%
We address this problem by using ideas for defunctionalization
from the theorem proving literature which
encode functions and lambdas using uninterpreted symbols.
This encoding lets us use (SMT-based) congruence closure to
reason about equality~(\S~\ref{sec:algorithmic}).
%
Of course, congruence is not enough; in general, \eg to prove
two functions extensionally equal, we require facilities for
manipulating function definitions.

\mypara{Language: Proof Composition}
%
Thus, as we wish to retrofit proofs into
existing languages, our second challenge:
how can we design a \emph{library of combinators}
that lets programmers \emph{compose proofs}
from basic refinements and function definitions?
%
We develop such a library, wherein proofs
are represented simply as unit-values
refined by the proposition that they
are proofs of. % ~(\S~\ref{sec:library}).
%
Refinement reflection lets us unfold definitions
simply by \emph{applying} the function to the
relevant inputs, and finally, we show how to
build up sophisticated proofs using a small
library of combinators that permit reasoning
in an algebraic or equational style.

\mypara{Implementation \& Evaluation}
%
We have implemented our approach in the \toolname
system, thereby retrofitting deep verification into
Haskell, converting it into an interactive proof
assistant.
%
\toolname's refinement types crucially allow us to
soundly account for the dreaded bottom by checking
that (refined) functions produce (non-bottom)
values~\cite{Vazou14}.
%
We evaluate our approach by using \toolname to
verify a variety of properties including arithmetic
properties of higher order, recursive functions,
textbook theorems about functions on inductively
defined datatypes, and the Monoid, Applicative,
Functor and Monad type class laws for a variety
of instances. %(\S~\ref{sec:evaluation}).
%
We demonstrate that our proofs look very much like
transcriptions of their pencil-and-paper analogues.
Yet, the proofs are plain Haskell functions, where
case-splitting and induction are performed by
plain pattern-matching and recursion.

% showing, that it may be possible to avail of the benefits
% of deep specification and verification without
% leaving the comforts of your favorite programming
% language.

To summarize, this paper describes a means of
retrofitting deep specification and verification
into your favorite language, by making the
following contributions:
%
\begin{itemize}
\item We start with an informal description of
      refinement reflection, and how it can
      be used to prove theorems about functions,
      by writing functions~(\S~\ref{sec:overview}).

\item We formalize refinement reflection using
      a core calculus, and prove it sound with
      respect to a denotational
      semantics~(\S~\ref{sec:formalism}).

\item We show how to keep type checking
      decidable~(\S~\ref{sec:algorithmic})
      while using uninterpreted functions and
      defunctionalization to reason about
      extensional equality in higher-order
      specifications~(\S~\ref{sec:lambdas}).

\item Finally, we have implemented refinement reflection
      in \toolname, a refinement type system for Haskell.
      We develop a library of (refined) proof combinators
      and evaluate our approach by proving various theorems
      about recursive, higher-order functions operating over
      integers and algebraic data types~(\S~\ref{sec:evaluation}).
\end{itemize}
