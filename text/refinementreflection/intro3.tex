\section{Introduction}\label{sec:intro}

We introduce \emph{refinement reflection}, a method
to extend \emph{legacy} languages---with highly tuned
libraries, compilers, and run-times---into theorem provers,
by letting programmers specify and verify
arbitrary properties of their code simply
by writing programs in the legacy language.

Previously, SMT-based refinement types
\citep{ConstableS87,Rushby98} have been
used to retrofit so-called ``shallow''
verification \eg array bounds checking into
%
ML~\cite{pfenningxi98,GordonRefinement09,LiquidPLDI08},
%
C~\cite{deputy,LiquidPOPL10},
%
Haskell~\citep{Vazou14},
%
TypeScript~\cite{Vekris16}, and
%
Racket~\cite{RefinedRacket}.
%
% Scala~\cite{ScalaLiquidTyper}.
%
To keep checking decidable, the specifications
are restricted to quantifier free formulas over
decidable theories.
%
However, to verify ``deep'' specifications as
in theorem proving languages like Agda, Coq, Dafny,
\fstar and Idris we require mechanisms that
\emph{represent} and \emph{manipulate} the
exact descriptions of user-defined functions.
%
So far, this has entailed either building new
languages on specialized type theories or
encoding functions with SMT axioms which makes
verification undecidable and hence, unpredictable.

% Refinement reflection lets us retrofit
% theorem proving onto legacy languages,
% while keeping verification decidable
% and predictable.
%
\mypara{1. Refinement Reflection}
%
Our first contribution is the notion of
refinement reflection: the code
implementing a​ user-defined function can
be \emph{reflected}​ into the function's
(output) refinement type, thus converting
the function's (refinement) type signature
into a deep specification of the functions
behavior.
%
This simple idea has a profound consequence:
at \emph{uses} of the function, the standard
rule for (dependent) function application
yields a precise, predictable and most
importantly, programmer controllable
means of \emph{instantiating} the deep
specification that is not tethered to
brittle SMT heuristics.
%
Specifically, we show how to use ideas for
\emph{defunctionalization} from the theorem
proving literature which encode functions
and lambdas using uninterpreted symbols,
to encode terms from an expressive higher
order language as decidable refinements,
letting us use SMT-based congruence
closure for decidable and predictable
verification~(\S~\ref{sec:theory}).

\mypara{2. A Library of Proof Combinators}
%
Our second contribution is a
\emph{library of combinators}
that lets programmers
\emph{compose proofs}
from basic refinements
and function definitions.
%
We show how to represent proofs
simply as unit-values refined
by the proposition that
they prove. %~(\S~\ref{sec:library}).
%
We show how to build up sophisticated proofs
using a small library of combinators that
permits reasoning in an algebraic or
equational style.
%
Furthermore, since proofs are literally
just programs, our proof combinators let
us use standard language mechanisms like
branches (to encode case splits),
recursion (to encode induction), and
functions (to encode auxiliary lemmas)
to write proofs that look very much like
transcriptions of their pencil-and-paper
analogues~(\S~\ref{sec:overview}).

\mypara{3. Verified Typeclass Laws}
%
Our third contribution is an implementation
of refinement reflection in \toolname~\citep{Vazou14},
thereby converting the legacy language
Haskell into a theorem prover.
%
We demonstrate the benefits of this conversion
by proving typeclass laws.
%
Haskell's typeclass machinery has led to
a suite of expressive abstractions and optimizations
which, for correctness, crucially require
typeclass \emph{instances} to obey key algebraic laws.
We show how reflection can be used to formally verify
that many widely used instances of the Monoid, Applicative,
Functor, and Monad typeclasses actually satisfy the
respective laws, making the use of these typeclasses safe~(\S~\ref{sec:evaluation}).

\mypara{4. Verified Deterministic Parallelism}
Finally, to showcase the benefits of retrofitting
theorem proving onto legacy languages, we perform
a case study in \emph{deterministic parallelism}.
%
%
Existing deterministic languages place unchecked
obligations on the user to guarantee, \eg the
associativity of a fold.
%
Violations can compromise type soundness
and correctness.
%
Closing this gap requires only modest proof
effort---touching only a small subset of
the application.
%
But for this solution to be possible requires a
\emph{practical}, \emph{parallel} programming
language that supports deep verification.
%
Before \toolname there was no such parallel language.
%
% Refinement reflection opens up this new possibility
% paving the way towards high-performance with
% correctness guarantees.
%
We show how \toolname lets us verify the unchecked obligations
from benchmarks taken from three existing parallel programming 
systems, and thus, paves the way towards 
high-performance with correctness guarantees~(\S~\ref{sec:eval-parallelism}).


% \new{We evaluate this possibility, taking small programs from three existing
%   parallel programming systems and verifying their unchecked
%   obligations~(\S~\ref{sec:eval-parallelism}).

%% To summarize, this paper describes a means of
%% retrofitting deep specification and verification
%% into your favorite language, by making the
%% following contributions:
%% %
%% \begin{itemize}
%% \item We start with an informal description of
      %% refinement reflection, and how it can
      %% be used to prove theorems about functions,
      %% by writing functions~(\S~\ref{sec:overview}).
%%
%% \item We formalize refinement reflection using
      %% a core calculus and prove soundness with
      %% respect to denotational
      %% semantics~(\S~\ref{sec:formalism}).
      %% Then, we show how to keep type checking
      %% decidable~(\S~\ref{sec:algorithmic})
      %% by using uninterpreted functions to
      %% reason about higher-order specifications.
%%
%% \item Finally, we have implemented refinement reflection
      %% in \toolname, a refinement type system for Haskell.
      %% We develop a library of (refined) proof combinators
      %% and evaluate our approach by proving various theorems
      %% about recursive, higher-order functions operating over
      %% integers and algebraic data types~(\S~\ref{sec:evaluation}).
%% \end{itemize}
